#include "ThreadPool.h"
#include "RakSleep.h"
#include <mutex>
#ifndef _WIN32
#include <unistd.h>
#endif

#ifdef _MSC_VER
#pragma warning(disable:4127)
#pragma warning(disable : 4701)  // potentially uninitialized local variable 'inputData' used
#endif

template<class ThreadInputType, class ThreadOutputType>
RAK_THREAD_DECLARATION(WorkerThread)
{
    auto *threadPool = (ThreadPool<ThreadInputType, ThreadOutputType> *) arguments;

    bool returnOutput;
    ThreadOutputType (*userCallback)(ThreadInputType, bool *, void *) = nullptr;
    ThreadInputType inputData;
    ThreadOutputType callbackOutput;

    void *perThreadData;
    if (threadPool->perThreadDataFactory)
        perThreadData = threadPool->perThreadDataFactory();
    else if (threadPool->threadDataInterface)
        perThreadData = threadPool->threadDataInterface->PerThreadFactory(threadPool->tdiContext);
    else
        perThreadData = nullptr;

    // Increase numThreadsRunning
    ++threadPool->numThreadsRunning;

    while (true)
    {
        if (userCallback == 0)
            threadPool->quitAndIncomingDataEvents.WaitOnEvent(1000);

        threadPool->runThreadsMutex.lock();
        if (!threadPool->runThreads)
        {
            threadPool->runThreadsMutex.unlock();
            break;
        }
        threadPool->runThreadsMutex.unlock();

        threadPool->workingThreadCountMutex.lock();
        ++threadPool->numThreadsWorking;
        threadPool->workingThreadCountMutex.unlock();

        // Read input data
        userCallback = 0;
        threadPool->inputQueueMutex.lock();
        if (threadPool->inputFunctionQueue.Size())
        {
            userCallback = threadPool->inputFunctionQueue.Pop();
            inputData = threadPool->inputQueue.Pop();
        }
        threadPool->inputQueueMutex.unlock();

        if (userCallback)
        {
            callbackOutput = userCallback(inputData, &returnOutput, perThreadData);
            if (returnOutput)
            {
                threadPool->outputQueueMutex.lock();
                threadPool->outputQueue.Push(callbackOutput);
                threadPool->outputQueueMutex.unlock();
            }
        }

        threadPool->workingThreadCountMutex.lock();
        --threadPool->numThreadsWorking;
        threadPool->workingThreadCountMutex.unlock();
    }

    // Decrease numThreadsRunning
    --threadPool->numThreadsRunning;

    if (threadPool->perThreadDataDestructor)
        threadPool->perThreadDataDestructor(perThreadData);
    else if (threadPool->threadDataInterface)
        threadPool->threadDataInterface->PerThreadDestructor(perThreadData, threadPool->tdiContext);

    return nullptr;
}

template<class InputType, class OutputType>
ThreadPool<InputType, OutputType>::ThreadPool()
{
    runThreads = false;
    numThreadsRunning = 0;
    threadDataInterface = 0;
    tdiContext = 0;
    numThreadsWorking = 0;

}

template<class InputType, class OutputType>
ThreadPool<InputType, OutputType>::~ThreadPool()
{
    StopThreads();
    Clear();
}

template<class InputType, class OutputType>
bool ThreadPool<InputType, OutputType>::StartThreads(int numThreads, PerThreadInit _perThreadDataFactory,
                                                     PerThreadDeinit _perThreadDataDestructor)
{

    runThreadsMutex.lock();

    if (runThreads)
    {
        // Already running
        runThreadsMutex.unlock();
        return false;
    }

    runThreadsMutex.unlock();

    quitAndIncomingDataEvents.InitEvent();

    perThreadDataFactory = _perThreadDataFactory;
    perThreadDataDestructor = _perThreadDataDestructor;

    runThreadsMutex.lock();
    runThreads = true;
    runThreadsMutex.unlock();

    numThreadsWorking = 0;
    for (int i = 0; i < numThreads; i++)
    {
        int errorCode = RakNet::RakThread::Create(WorkerThread<InputType, OutputType>, this);

        if (errorCode != 0)
        {
            StopThreads();
            return false;
        }
    }

    // Wait for number of threads running to increase to numThreads
    bool done = false;
    while (!done)
    {
        RakSleep(50);
        if (numThreadsRunning == numThreads)
            done = true;
    }

    return true;
}

template<class InputType, class OutputType>
void ThreadPool<InputType, OutputType>::SetThreadDataInterface(ThreadDataInterface *tdi, void *context)
{
    threadDataInterface = tdi;
    tdiContext = context;
}

template<class InputType, class OutputType>
void ThreadPool<InputType, OutputType>::StopThreads()
{
    runThreadsMutex.lock();
    if (!runThreads)
    {
        runThreadsMutex.unlock();
        return;
    }

    runThreads = false;
    runThreadsMutex.unlock();

    // Wait for number of threads running to decrease to 0
    bool done = false;
    while (!done)
    {
        quitAndIncomingDataEvents.SetEvent();

        RakSleep(50);
        if (numThreadsRunning == 0)
            done = true;
    }

    quitAndIncomingDataEvents.CloseEvent();
}

template<class InputType, class OutputType>
void ThreadPool<InputType, OutputType>::AddInput(WorkerThreadCallback workerThreadCallback, InputType inputData)
{
    inputQueueMutex.lock();
    inputQueue.Push(inputData);
    inputFunctionQueue.Push(workerThreadCallback);
    inputQueueMutex.unlock();

    quitAndIncomingDataEvents.SetEvent();
}

template<class InputType, class OutputType>
void ThreadPool<InputType, OutputType>::AddOutput(OutputType outputData)
{
    outputQueueMutex.lock();
    outputQueue.Push(outputData);
    outputQueueMutex.unlock();
}

template<class InputType, class OutputType>
bool ThreadPool<InputType, OutputType>::HasOutputFast()
{
    return !outputQueue.IsEmpty();
}

template<class InputType, class OutputType>
bool ThreadPool<InputType, OutputType>::HasOutput()
{
    std::lock_guard<RakNet::SimpleMutex> lock(outputQueueMutex);
    bool res = !outputQueue.IsEmpty();
    return res;
}

template<class InputType, class OutputType>
bool ThreadPool<InputType, OutputType>::HasInputFast()
{
    return !inputQueue.IsEmpty();
}

template<class InputType, class OutputType>
bool ThreadPool<InputType, OutputType>::HasInput()
{
    inputQueueMutex.lock();
    bool res = !inputQueue.IsEmpty();
    inputQueueMutex.unlock();
    return res;
}

template<class InputType, class OutputType>
OutputType ThreadPool<InputType, OutputType>::GetOutput()
{
    // Real output check
    outputQueueMutex.lock();
    OutputType output = outputQueue.Pop();
    outputQueueMutex.unlock();
    return output;
}

template<class InputType, class OutputType>
void ThreadPool<InputType, OutputType>::Clear()
{
    runThreadsMutex.lock();
    if (runThreads)
    {
        runThreadsMutex.unlock();
        inputQueueMutex.lock();
        inputFunctionQueue.Clear();
        inputQueue.Clear();
        inputQueueMutex.unlock();

        outputQueueMutex.lock();
        outputQueue.Clear();
        outputQueueMutex.unlock();
    }
    else
    {
        inputFunctionQueue.Clear();
        inputQueue.Clear();
        outputQueue.Clear();
    }
}

template<class InputType, class OutputType>
void ThreadPool<InputType, OutputType>::LockInput()
{
    inputQueueMutex.lock();
}

template<class InputType, class OutputType>
void ThreadPool<InputType, OutputType>::UnlockInput()
{
    inputQueueMutex.unlock();
}

template<class InputType, class OutputType>
unsigned ThreadPool<InputType, OutputType>::InputSize()
{
    return inputQueue.Size();
}

template<class InputType, class OutputType>
InputType ThreadPool<InputType, OutputType>::GetInputAtIndex(unsigned index)
{
    return inputQueue[index];
}

template<class InputType, class OutputType>
void ThreadPool<InputType, OutputType>::RemoveInputAtIndex(unsigned index)
{
    inputQueue.RemoveAtIndex(index);
    inputFunctionQueue.RemoveAtIndex(index);
}

template<class InputType, class OutputType>
void ThreadPool<InputType, OutputType>::LockOutput()
{
    outputQueueMutex.lock();
}

template<class InputType, class OutputType>
void ThreadPool<InputType, OutputType>::UnlockOutput()
{
    outputQueueMutex.unlock();
}

template<class InputType, class OutputType>
unsigned ThreadPool<InputType, OutputType>::OutputSize()
{
    return outputQueue.Size();
}

template<class InputType, class OutputType>
OutputType ThreadPool<InputType, OutputType>::GetOutputAtIndex(unsigned index)
{
    return outputQueue[index];
}

template<class InputType, class OutputType>
void ThreadPool<InputType, OutputType>::RemoveOutputAtIndex(unsigned index)
{
    outputQueue.RemoveAtIndex(index);
}

template<class InputType, class OutputType>
void ThreadPool<InputType, OutputType>::ClearInput()
{
    inputQueue.Clear();
    inputFunctionQueue.Clear();
}

template<class InputType, class OutputType>
void ThreadPool<InputType, OutputType>::ClearOutput()
{
    outputQueue.Clear();
}

template<class InputType, class OutputType>
bool ThreadPool<InputType, OutputType>::IsWorking()
{

    // Bug fix: Originally the order of these two was reversed.
    // It's possible with the thread timing that working could have been false, then it picks up the data in the other thread, then it checks
    // here and sees there is no data.  So it thinks the thread is not working when it was.
    if (HasOutputFast() && HasOutput())
        return true;

    if (HasInputFast() && HasInput())
        return true;

    // Need to check is working again, in case the thread was between the first and second checks
    workingThreadCountMutex.lock();
    bool isWorking = numThreadsWorking != 0;
    workingThreadCountMutex.unlock();

    return isWorking;
}

template<class InputType, class OutputType>
int ThreadPool<InputType, OutputType>::NumThreadsWorking()
{
    return numThreadsWorking;
}

template<class InputType, class OutputType>
bool ThreadPool<InputType, OutputType>::WasStarted()
{
    runThreadsMutex.lock();
    bool b = runThreads;
    runThreadsMutex.unlock();
    return b;
}

template<class InputType, class OutputType>
bool ThreadPool<InputType, OutputType>::Pause()
{
    if (!WasStarted())
        return false;

    workingThreadCountMutex.lock();
    while (numThreadsWorking > 0)
    {
        RakSleep(30);
    }
    return true;
}

template<class InputType, class OutputType>
void ThreadPool<InputType, OutputType>::Resume()
{
    workingThreadCountMutex.unlock();
}